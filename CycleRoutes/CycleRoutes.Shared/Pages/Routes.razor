@page "/routes"
@inject IRouteService RouteService
@inject IStreetViewService StreetViewService
@inject IGoogleMapsService GoogleMapsService
@inject IJSRuntime JSRuntime
@implements IDisposable

<PageTitle>CycleRoutes</PageTitle>

<div class="container-fluid">
    <div class="row">
        <div class="@(isRouteManagementCollapsed ? "" : "col-md-4") route-management-panel @(isRouteManagementCollapsed ? "collapsed" : "")" style="@(isRouteManagementCollapsed ? "width: 60px; flex: 0 0 60px;" : "")">
            <div class="card">
                <div class="card-header d-flex justify-content-between align-items-center @(isRouteManagementCollapsed ? "px-1 py-2" : "")">
                    <h5 class="mb-0 @(isRouteManagementCollapsed ? "d-none" : "")">Route Management</h5>
                    <button class="btn btn-sm btn-outline-secondary route-management-toggle @(isRouteManagementCollapsed ? "w-100" : "")" @onclick="ToggleRouteManagement" title="@(isRouteManagementCollapsed ? "Expand Panel" : "Collapse Panel")" style="@(isRouteManagementCollapsed ? "min-height: 40px;" : "")">
                        @if (isRouteManagementCollapsed)
                        {
                            <SvgIcon Icon="chevron-right" Style="transform: scale(1.2);" />
                        }
                        else
                        {
                            <SvgIcon Icon="chevron-left" Style="transform: scale(1.2);" />
                        }
                    </button>
                </div>
                @if (!isRouteManagementCollapsed)
                {
                    <div class="card-body">
                        <!-- File Upload -->
                        <div class="mb-3">
                            <label for="gpxFile" class="form-label">Upload GPX File</label>
                            <InputFile OnChange="OnFileSelected" accept=".gpx" class="form-control" id="gpxFile" />
                        </div>

                        @if (isLoading)
                        {
                            <div class="text-center">
                                <div class="spinner-border text-primary" role="status">
                                    <span class="visually-hidden">Loading...</span>
                                </div>
                                <p class="mt-2">Loading route...</p>
                            </div>
                        }

                        @if (!string.IsNullOrEmpty(statusMessage))
                        {
                            <div class="alert @(statusMessage.Contains("Error") ? "alert-danger" : "alert-success") alert-dismissible fade show" role="alert">
                                @statusMessage
                                <button type="button" class="btn-close" @onclick="DismissAlert" aria-label="Close"></button>
                            </div>
                        }

                        <!-- Saved Routes -->
                        <div class="mb-3">
                            <h6>Saved Routes</h6>
                            @if (savedRoutes.Any())
                            {
                                <div class="list-group">
                                    @foreach (var route in savedRoutes)
                                    {
                                        <div class="list-group-item d-flex justify-content-between align-items-center">
                                            <div>
                                                <strong>@route.Name</strong><br>
                                                <small class="text-muted">
                                                    @{
                                                        var actualDistance = route.CalculateTotalDistance();
                                                        var distanceKm = actualDistance / 1000;
                                                        var distanceMiles = distanceKm * 0.621371;
                                                    }
                                                    @(distanceKm.ToString("F1")) km (@(distanceMiles.ToString("F1")) mi) ‚Ä¢ @route.Points.Count points
                                                </small>
                                            </div>
                                            <div>
                                                <button class="btn btn-sm btn-primary me-1" @onclick="() => LoadRoute(route)">
                                                    Load
                                                </button>
                                                <button class="btn btn-sm btn-danger" @onclick="() => DeleteRoute(route.Name)">
                                                    Delete
                                                </button>
                                            </div>
                                        </div>
                                    }
                                </div>
                            }
                            else
                            {
                                <p class="text-muted">No saved routes</p>
                            }
                        </div>
                    </div>
                }
                else
                {
                    <div class="card-body d-flex flex-column align-items-center justify-content-center text-center py-2" style="min-height: 100px;">
                        <div class="text-muted mb-2" style="writing-mode: vertical-lr; transform: rotate(180deg); letter-spacing: 2px; font-weight: 500; font-size: 0.7rem;">
                            ROUTES
                        </div>
                        <div class="text-muted" style="font-size: 0.8rem;">
                            üìÅ
                        </div>
                    </div>
                }
            </div>

            <!-- Current Route Info -->
            @if (currentRoute != null && !isRouteManagementCollapsed)
            {
                <div class="card mt-3">
                    <div class="card-header">
                        <h6 class="mb-0">Current Route: @currentRoute.Name</h6>
                    </div>
                    <div class="card-body">
                        <p><strong>Distance:</strong> @{
                            var totalDistanceKm = (currentRoute.CalculateTotalDistance() / 1000);
                            var totalDistanceMiles = totalDistanceKm * 0.621371;
                        }@(totalDistanceKm.ToString("F1")) km (@(totalDistanceMiles.ToString("F1")) mi)</p>
                        <p><strong>Points:</strong> @currentRoute.Points.Count</p>
                        @if (!isNavigating)
                        {
                            <button class="btn btn-success" @onclick="StartRoute">
                                <SvgIcon Icon="play-fill" CssClass="me-1" /> Start Navigation
                            </button>
                        }
                        else
                        {
                            <button class="btn btn-danger me-2" @onclick="StopRoute">
                                <SvgIcon Icon="stop-fill" CssClass="me-1" /> Stop
                            </button>
                            <div class="mt-2">
                                <small class="text-muted">Point @(currentPointIndex + 1) of @currentRoute.Points.Count</small>
                            </div>
                        }
                    </div>
                </div>
            }
        </div>

        <div class="@(isRouteManagementCollapsed ? "" : "col-md-8")" style="@(isRouteManagementCollapsed ? "flex: 1;" : "")">
            @if (currentRoute != null && currentRoute.Points.Any())
            {
                var currentPoint = isNavigating ? currentRoute.Points[currentPointIndex] : currentRoute.StartPoint!;
                
                <div class="card">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Street View</h6>
                        <div class="d-flex align-items-center">
                            <!-- Auto-advance controls - always visible when route is loaded -->
                            <div class="btn-group me-2" role="group" aria-label="Auto-advance controls">
                                <label for="distanceSelect" class="btn btn-sm btn-outline-secondary d-flex align-items-center" style="min-width: 80px; height: 31px; cursor: pointer;">
                                    <SvgIcon Icon="rulers" CssClass="me-1" />
                                    <span class="d-none d-lg-inline">Distance:</span>
                                </label>
                                <select id="distanceSelect" class="form-select form-select-sm" @bind="autoAdvanceDistanceMeters" style="width: 80px; height: 31px; font-size: 0.8rem;">
                                    <option value="10">10m</option>
                                    <option value="20">20m</option>
                                    <option value="30">30m</option>
                                    <option value="50">50m</option>
                                    <option value="100">100m</option>
                                    <option value="200">200m</option>
                                    <option value="500">500m</option>
                                </select>
                            </div>
                            
                            <div class="btn-group me-2" role="group" aria-label="Auto-advance delay">
                                <label for="delaySelect" class="btn btn-sm btn-outline-secondary d-flex align-items-center" style="min-width: 70px; height: 31px; cursor: pointer;">
                                    <SvgIcon Icon="clock" CssClass="me-1" />
                                    <span class="d-none d-lg-inline">Delay:</span>
                                </label>
                                <select id="delaySelect" class="form-select form-select-sm" @bind="autoAdvanceIntervalSeconds" style="width: 70px; height: 31px; font-size: 0.8rem;">
                                    <option value="1">1s</option>
                                    <option value="2">2s</option>
                                    <option value="3">3s</option>
                                    <option value="4">4s</option>
                                    <option value="5">5s</option>
                                    <option value="10">10s</option>
                                </select>
                            </div>
                            
                            <!-- Speed Display -->
                            <div class="btn-group me-2" role="group" aria-label="Current speed">
                                <label class="btn btn-sm btn-outline-info d-flex align-items-center" style="min-width: 90px; height: 31px; cursor: default;">
                                    <SvgIcon Icon="speedometer2" CssClass="me-1" />
                                    <span class="d-none d-lg-inline">Speed:</span>
                                </label>
                                <div class="btn btn-sm btn-outline-info d-flex align-items-center" style="min-width: 80px; height: 31px; cursor: default; font-size: 0.8rem;">
                                    @CalculateCurrentSpeed().ToString("F1") mph
                                </div>
                            </div>
                            
                            @if (isNavigating)
                            {
                                <div class="btn-group me-2" role="group" aria-label="Navigation controls">
                                    <button class="btn btn-sm btn-outline-primary d-flex align-items-center justify-content-center" @onclick="PreviousDistance" disabled="@(currentPointIndex == 0)" title="Previous @(autoAdvanceDistanceMeters)m" style="min-width: 36px; height: 31px;">
                                        <SvgIcon Icon="chevron-left" />
                                    </button>
                                    
                                    @if (isAutoAdvancing)
                                    {
                                        @if (isAutoAdvancePaused)
                                        {
                                            <button class="btn btn-sm btn-outline-primary d-flex align-items-center justify-content-center" @onclick="ResumeAutoAdvance" title="Resume Auto Advance" style="min-width: 70px; height: 31px;">
                                                <SvgIcon Icon="play" CssClass="me-1" />
                                                <span class="d-none d-md-inline">Resume</span>
                                            </button>
                                        }
                                        else
                                        {
                                            <button class="btn btn-sm btn-outline-primary d-flex align-items-center justify-content-center" @onclick="PauseAutoAdvance" title="Pause Auto Advance" style="min-width: 70px; height: 31px;">
                                                <SvgIcon Icon="pause" CssClass="me-1" />
                                                <span class="d-none d-md-inline">Pause</span>
                                            </button>
                                        }
                                        <button class="btn btn-sm btn-outline-primary d-flex align-items-center justify-content-center" @onclick="StopAutoAdvance" title="Stop Auto Advance" style="min-width: 60px; height: 31px;">
                                            <SvgIcon Icon="stop" CssClass="me-1" />
                                            <span class="d-none d-lg-inline">Stop</span>
                                        </button>
                                    }
                                    else
                                    {
                                        <button class="btn btn-sm btn-outline-primary d-flex align-items-center justify-content-center" @onclick="StartAutoAdvance" title="Start Auto Advance" style="min-width: 60px; height: 31px;">
                                            <SvgIcon Icon="fast-forward" CssClass="me-1" />
                                            <span class="d-none d-md-inline">Auto</span>
                                        </button>
                                    }
                                </div>
                                    
                                <button class="btn btn-sm btn-outline-primary d-flex align-items-center justify-content-center" @onclick="NextDistance" disabled="@(currentPointIndex >= currentRoute.Points.Count - 1)" title="Next @(autoAdvanceDistanceMeters)m" style="min-width: 36px; height: 31px;">
                                    <SvgIcon Icon="chevron-right" />
                                </button>
                            }
                            <button class="btn btn-sm btn-outline-secondary" @onclick="RefreshStreetView" title="Refresh Street View">
                                <SvgIcon Icon="arrow-clockwise" />
                            </button>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        @if (StreetViewService.HasApiKey)
                        {
                            var heading = CalculateOptimalHeading(currentPoint, currentPointIndex);
                            var streetViewUrl = StreetViewService.GetStreetViewEmbedUrl(currentPoint.Latitude, currentPoint.Longitude, heading, 75, -5);
                            if (!string.IsNullOrEmpty(streetViewUrl))
                            {
                                <!-- Force iframe reload using unique key and container replacement for production caching issues -->
                                var iframeId = $"streetview-iframe-{currentPointIndex}-{streetViewRefreshCounter}";
                                <div id="streetview-container-@currentPointIndex-@streetViewRefreshCounter" class="position-relative">
                                    <iframe id="@iframeId"
                                            src="@streetViewUrl" 
                                            key="@($"streetview-{currentPointIndex}-{streetViewRefreshCounter}")"
                                            width="100%" height="400" style="border: none;"
                                            title="Google Street View" 
                                            allowfullscreen="true"
                                            loading="eager"
                                            onload="console.log('Street View iframe loaded successfully for point @currentPointIndex, refresh: @streetViewRefreshCounter')"
                                            onerror="console.error('Street View iframe failed to load for point @currentPointIndex'); this.style.backgroundColor='#f8f9fa';"
                                            onabort="console.warn('Street View iframe loading aborted for point @currentPointIndex')"></iframe>
                                    <div class="position-absolute top-0 start-50 translate-middle-x m-2">
                                        <small class="badge bg-secondary">
                                            Point @(currentPointIndex + 1): @currentPoint.Latitude.ToString("F6"), @currentPoint.Longitude.ToString("F6")
                                        </small>
                                    </div>
                                    @if (Environment.GetEnvironmentVariable("ASPNETCORE_ENVIRONMENT") == "Development")
                                    {
                                        <div class="position-absolute bottom-0 start-0 m-2">
                                            <small class="badge bg-info">
                                                Debug: Point @currentPointIndex, Refresh @streetViewRefreshCounter
                                            </small>
                                        </div>
                                    }
                                </div>
                            }
                            else
                            {
                                <div class="alert alert-warning m-3" role="alert">
                                    <h6>Street View Unavailable</h6>
                                    <p class="mb-2">Street View could not be loaded. Showing map view instead.</p>
                                    <small class="text-muted">This could be due to API quota limits, billing issues, or Street View not being available at this location.</small>
                                </div>
                                <!-- Fallback to regular Google Maps -->
                                var fallbackMapUrl = StreetViewService.GetFallbackMapUrl(currentPoint.Latitude, currentPoint.Longitude, 18);
                                if (!string.IsNullOrEmpty(fallbackMapUrl))
                                {
                                    <iframe src="@fallbackMapUrl" 
                                            key="@($"fallback-{currentPointIndex}-{streetViewRefreshCounter}")"
                                            width="100%" height="400" style="border: none;"
                                            title="Google Maps - Fallback View" 
                                            allowfullscreen="true"></iframe>
                                }
                                else
                                {
                                    <div class="alert alert-danger m-3" role="alert">
                                        <h6>Maps Unavailable</h6>
                                        <p class="mb-0">Both Street View and fallback map could not be loaded.</p>
                                    </div>
                                }
                            }
                        }
                        else
                        {
                            <div class="alert alert-warning m-3" role="alert">
                                <h6>Google Street View API Key Required</h6>
                                <p class="mb-2">@apiKeyStatusMessage</p>
                                @if (isValidatingApiKey)
                                {
                                    <div class="spinner-border spinner-border-sm me-2" role="status"></div>
                                    <span>Validating API key...</span>
                                }
                                else
                                {
                                    <button class="btn btn-sm btn-primary" @onclick="ValidateApiKey">
                                        Validate API Key
                                    </button>
                                }
                            </div>
                        }
                    </div>
                </div>

                <!-- Google Maps Route Overview -->
                <div class="card mt-3">
                    <div class="card-header d-flex justify-content-between align-items-center">
                        <h6 class="mb-0">Route Overview</h6>
                        <div>
                            <small class="text-muted">Click on the route to jump to that point</small>
                        </div>
                    </div>
                    <div class="card-body p-0">
                        @if (GoogleMapsService.HasApiKey)
                        {
                            @if (isMapLoading)
                            {
                                <div class="d-flex justify-content-center align-items-center" style="height: 400px;">
                                    <div class="text-center">
                                        <div class="spinner-border text-primary" role="status">
                                            <span class="visually-hidden">Loading map...</span>
                                        </div>
                                        <p class="mt-2">Loading map...</p>
                                    </div>
                                </div>
                            }
                            <div id="routeMap" style="height: 400px; width: 100%;" class="@(isMapLoading ? "d-none" : "")"></div>
                        }
                        else
                        {
                            <div class="alert alert-warning m-3" role="alert">
                                <h6>Google Maps API Key Required</h6>
                                <p class="mb-0">@apiKeyStatusMessage</p>
                            </div>
                        }
                    </div>
                </div>

                <!-- Progress Bar -->
                @if (isNavigating)
                {
                    <div class="card mt-3">
                        <div class="card-body">
                            <div class="d-flex justify-content-between align-items-center mb-2">
                                <span class="text-muted">Progress: @(currentPointIndex + 1) / @currentRoute.Points.Count</span>
                                <span class="text-muted">@(((double)(currentPointIndex + 1) / currentRoute.Points.Count * 100).ToString("F1"))%</span>
                            </div>
                            <div class="progress clickable-progress" id="clickable-progress" style="height: 25px; cursor: pointer;" @onclick="OnProgressBarClick">
                                <div class="progress-bar" 
                                     role="progressbar" 
                                     style="width: @(((double)(currentPointIndex + 1) / currentRoute.Points.Count * 100).ToString("F1"))%"
                                     aria-valuenow="@(currentPointIndex + 1)" 
                                     aria-valuemin="0" 
                                     aria-valuemax="@currentRoute.Points.Count">
                                    Point @(currentPointIndex + 1)
                                </div>
                            </div>
                        </div>
                    </div>
                }
            }
            else
            {
                <div class="card">
                    <div class="card-body text-center">
                        <h5 class="text-muted">No Route Loaded</h5>
                        <p class="text-muted">Upload a GPX file to get started with route navigation.</p>
                    </div>
                </div>
            }
        </div>
    </div>
</div>

@code {
    private static Routes? _instance;
    private List<CycleRoute> savedRoutes = new();
    private CycleRoute? currentRoute;
    private bool isLoading;
    private string statusMessage = string.Empty;
    private bool isNavigating;
    private int currentPointIndex;
    private bool isValidatingApiKey;
    private string apiKeyStatusMessage = string.Empty;
    private bool isRouteManagementCollapsed = false;

    // Google Maps functionality
    private bool isMapLoading = true;
    private bool isMapInitialized = false;
    private bool isComponentRendered = false;

    // Auto-advance functionality
    private bool isAutoAdvancing;
    private bool isAutoAdvancePaused;
    private int _autoAdvanceIntervalSeconds = 3;
    private int autoAdvanceIntervalSeconds
    {
        get => _autoAdvanceIntervalSeconds;
        set
        {
            if (_autoAdvanceIntervalSeconds != value)
            {
                _autoAdvanceIntervalSeconds = value;
                RestartAutoAdvanceTimerIfActive();
            }
        }
    }
    private int _autoAdvanceDistanceMeters = 30;
    private int autoAdvanceDistanceMeters
    {
        get => _autoAdvanceDistanceMeters;
        set
        {
            if (_autoAdvanceDistanceMeters != value)
            {
                _autoAdvanceDistanceMeters = value;
                // No need to restart timer for distance changes
            }
        }
    }
    private string autoAdvanceDirection = "forward";
    private Timer? autoAdvanceTimer;
    
    // Street View refresh helper
    private int streetViewRefreshCounter = 0;

    protected override async Task OnInitializedAsync()
    {
        _instance = this;
        RouteService.CurrentRouteChanged += OnCurrentRouteChanged;
        savedRoutes = await RouteService.GetSavedRoutesAsync();
        currentRoute = RouteService.CurrentRoute;
        
        // For WebAssembly, call ValidateApiKeyAsync which will ensure configuration is loaded
        await GoogleMapsService.ValidateApiKeyAsync();
        
        await UpdateApiKeyStatus();
    }

    protected override async Task OnAfterRenderAsync(bool firstRender)
    {
        if (firstRender)
        {
            isComponentRendered = true;
            
            // Add JavaScript to handle dropdown opening when labels are clicked
            await JSRuntime.InvokeVoidAsync("eval", @"
                // Function to open select dropdown
                function openSelectDropdown(selectElement) {
                    if (selectElement) {
                        selectElement.focus();
                        selectElement.click();
                        // For some browsers, we need to dispatch a mousedown event
                        const event = new MouseEvent('mousedown', { bubbles: true });
                        selectElement.dispatchEvent(event);
                    }
                }

                // Add event listeners for distance and delay labels
                const distanceLabel = document.querySelector('label[for=""distanceSelect""]');
                const delayLabel = document.querySelector('label[for=""delaySelect""]');
                
                if (distanceLabel) {
                    distanceLabel.addEventListener('click', function() {
                        const select = document.getElementById('distanceSelect');
                        openSelectDropdown(select);
                    });
                }
                
                if (delayLabel) {
                    delayLabel.addEventListener('click', function() {
                        const select = document.getElementById('delaySelect');
                        openSelectDropdown(select);
                    });
                }
            ");
            
            if (currentRoute != null)
            {
                await InitializeMap();
            }
        }
    }

    private async Task UpdateApiKeyStatus()
    {
        apiKeyStatusMessage = StreetViewService.GetApiKeyStatus();
        if (StreetViewService.HasApiKey)
        {
            isValidatingApiKey = true;
            StateHasChanged();
            
            var isValid = await StreetViewService.ValidateApiKeyAsync();
            apiKeyStatusMessage = StreetViewService.GetApiKeyStatus();
            
            isValidatingApiKey = false;
            StateHasChanged();
        }
    }

    private async Task ValidateApiKey()
    {
        await UpdateApiKeyStatus();
    }

    private async Task InitializeMap()
    {
        if (currentRoute == null)
        {
            Console.WriteLine("Cannot initialize map - missing route");
            return;
        }

        try
        {
            Console.WriteLine("Starting map initialization...");
            isMapLoading = true;
            StateHasChanged();

            // For WebAssembly, ensure we load configuration first
            if (!GoogleMapsService.HasApiKey)
            {
                Console.WriteLine("No API key available, attempting to load configuration...");
                await GoogleMapsService.ValidateApiKeyAsync();
            }

            // Check if we have API key after potential loading
            if (!GoogleMapsService.HasApiKey)
            {
                Console.WriteLine("Cannot initialize map - missing API key after configuration attempt");
                isMapLoading = false;
                StateHasChanged();
                return;
            }

            // Check if we can safely call JSRuntime
            try
            {
                // Ensure the map container exists
                var mapExists = await JSRuntime.InvokeAsync<bool>("eval", "document.getElementById('routeMap') !== null");
                if (!mapExists)
                {
                    Console.WriteLine("Map container not found, waiting...");
                    await Task.Delay(1000);
                    mapExists = await JSRuntime.InvokeAsync<bool>("eval", "document.getElementById('routeMap') !== null");
                    if (!mapExists)
                    {
                        Console.WriteLine("Map container still not found after delay");
                        isMapLoading = false;
                        StateHasChanged();
                        return;
                    }
                }
            }
            catch (InvalidOperationException ex) when (ex.Message.Contains("statically rendered"))
            {
                Console.WriteLine("Cannot initialize map yet - component still in static rendering phase");
                isMapLoading = false;
                StateHasChanged();
                return;
            }

            Console.WriteLine("Map container found, proceeding with initialization...");

            // Generate scripts
            var mapScript = GoogleMapsService.GenerateMapInitializationScript(currentRoute, "routeMap", currentPointIndex);
            var clickScript = GoogleMapsService.GenerateRouteClickScript(currentRoute, "onRouteMapClick");
            
            // Set up the callback function for route clicks
            await JSRuntime.InvokeVoidAsync("eval", @"
                window.onRouteMapClick = function(pointIndex) {
                    DotNet.invokeMethodAsync('CycleRoutes.Shared', 'OnMapRouteClick', pointIndex);
                };
            ");
            
            // Define the callback function that the Google Maps API will call
            var initScript = $@"
                window.initGoogleMaps = function() {{
                    console.log('Google Maps API callback triggered');
                    window.googleMapsApiLoaded = true;
                    try {{
                        {mapScript}
                        console.log('Route map initialized successfully');
                        
                        // Add click listeners to the route
                        {clickScript}
                        
                    }} catch (error) {{
                        console.error('Error initializing route map:', error);
                    }}
                }};
            ";
            
            await JSRuntime.InvokeVoidAsync("eval", initScript);

            // Load the Google Maps API if not already loaded
            if (!isMapInitialized)
            {
                Console.WriteLine("Loading Google Maps API...");
                var loadScript = $@"
                    console.log('Checking if Google Maps API is loaded...');
                    if (!window.googleMapsApiLoaded) {{
                        console.log('Loading Google Maps API script...');
                        const script = document.createElement('script');
                        script.src = '{GoogleMapsService.GetMapsApiUrl()}';
                        script.async = true;
                        script.defer = true;
                        script.onerror = function() {{
                            console.error('Failed to load Google Maps API');
                        }};
                        document.head.appendChild(script);
                    }} else {{
                        console.log('Google Maps API already loaded, initializing map...');
                        if (window.initGoogleMaps) {{
                            window.initGoogleMaps();
                        }}
                    }}
                ";

                await JSRuntime.InvokeVoidAsync("eval", loadScript);
            }
            
            // If API is already loaded, call the callback immediately
            await JSRuntime.InvokeVoidAsync("eval", @"
                if (window.googleMapsApiLoaded && typeof google !== 'undefined') {
                    console.log('Google Maps API already ready, calling callback immediately...');
                    window.initGoogleMaps();
                } else {
                    console.log('Waiting for Google Maps API to load...');
                }
            ");

            isMapInitialized = true;
            
            // Give it a moment to initialize
            await Task.Delay(2000);
            
            isMapLoading = false;
            StateHasChanged();
            Console.WriteLine("Map initialization completed");
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error initializing map: {ex.Message}");
            isMapLoading = false;
            StateHasChanged();
        }
    }

    private async Task UpdateMapPosition()
    {
        if (currentRoute == null || !GoogleMapsService.HasApiKey || !isMapInitialized)
            return;

        try
        {
            var currentPoint = currentRoute.Points[currentPointIndex];
            var updateScript = GoogleMapsService.GenerateUpdatePositionScript(currentPoint, "routeMap");
            await JSRuntime.InvokeVoidAsync("eval", updateScript);
        }
        catch (Exception ex)
        {
            Console.WriteLine($"Error updating map position: {ex.Message}");
        }
    }

    private void DismissAlert()
    {
        statusMessage = string.Empty;
        StateHasChanged();
    }

    private void ToggleRouteManagement()
    {
        isRouteManagementCollapsed = !isRouteManagementCollapsed;
    }

    private void OnCurrentRouteChanged(CycleRoute? route)
    {
        InvokeAsync(async () =>
        {
            currentRoute = route;
            isNavigating = false;
            currentPointIndex = 0;
            isMapLoading = true;
            isMapInitialized = false;
            StopAutoAdvance();
            
            StateHasChanged();
            
            // Always try to initialize map when route changes, with proper checks inside InitializeMap
            if (currentRoute != null && GoogleMapsService.HasApiKey)
            {
                // Add a small delay to ensure the DOM is ready
                await Task.Delay(500);
                await InitializeMap();
            }
        });
    }

    private async Task OnFileSelected(InputFileChangeEventArgs e)
    {
        var file = e.File;
        if (file == null) return;

        isLoading = true;
        statusMessage = string.Empty;
        StateHasChanged();

        try
        {
            using var stream = file.OpenReadStream(maxAllowedSize: 10 * 1024 * 1024); // 10MB limit
            var route = await RouteService.LoadRouteFromGpxAsync(stream, file.Name);

            if (route != null)
            {
                await RouteService.SaveRouteAsync(route);
                RouteService.SetCurrentRoute(route);
                savedRoutes = await RouteService.GetSavedRoutesAsync();
                statusMessage = $"Successfully loaded route '{route.Name}' with {route.Points.Count} points.";
            }
            else
            {
                statusMessage = "Error: Could not load route from the selected file.";
            }
        }
        catch (Exception ex)
        {
            statusMessage = $"Error loading file: {ex.Message}";
        }
        finally
        {
            isLoading = false;
            StateHasChanged();
        }
    }

    private void LoadRoute(CycleRoute route)
    {
        RouteService.SetCurrentRoute(route);
        statusMessage = $"Loaded route '{route.Name}'";
    }

    private async Task DeleteRoute(string routeName)
    {
        await RouteService.DeleteRouteAsync(routeName);
        savedRoutes = await RouteService.GetSavedRoutesAsync();
        statusMessage = $"Deleted route '{routeName}'";
        StateHasChanged();
    }

    private void StartRoute()
    {
        if (currentRoute == null || !currentRoute.Points.Any()) return;

        isNavigating = true;
        currentPointIndex = 0;
        
        // Automatically start auto-advance for better user experience
        StartAutoAdvance();
        
        StateHasChanged();
    }

    private void StopRoute()
    {
        isNavigating = false;
        StopAutoAdvance();
        StateHasChanged();
    }

    private void StartAutoAdvance()
    {
        if (currentRoute == null || !currentRoute.Points.Any()) return;

        isAutoAdvancing = true;
        isAutoAdvancePaused = false;
        CreateAutoAdvanceTimer();
        StateHasChanged();
    }

    private void PauseAutoAdvance()
    {
        isAutoAdvancePaused = true;
        autoAdvanceTimer?.Dispose();
        StateHasChanged();
    }

    private void ResumeAutoAdvance()
    {
        isAutoAdvancePaused = false;
        CreateAutoAdvanceTimer();
        StateHasChanged();
    }

    private void StopAutoAdvance()
    {
        isAutoAdvancing = false;
        isAutoAdvancePaused = false;
        autoAdvanceTimer?.Dispose();
        StateHasChanged();
    }

    private void CreateAutoAdvanceTimer()
    {
        autoAdvanceTimer?.Dispose();
        autoAdvanceTimer = new Timer(AutoAdvanceCallback, null, 
            TimeSpan.FromSeconds(autoAdvanceIntervalSeconds), 
            TimeSpan.FromSeconds(autoAdvanceIntervalSeconds));
    }

    private void RestartAutoAdvanceTimerIfActive()
    {
        if (isAutoAdvancing && !isAutoAdvancePaused)
        {
            CreateAutoAdvanceTimer();
        }
    }

    private void AutoAdvanceCallback(object? state)
    {
        if (!isAutoAdvancing || isAutoAdvancePaused || currentRoute == null)
            return;

        InvokeAsync(() =>
        {
            if (autoAdvanceDirection == "forward")
            {
                if (currentPointIndex < currentRoute.Points.Count - 1)
                {
                    NextDistance();
                }
                else
                {
                    // Reached the end, stop auto-advance
                    StopAutoAdvance();
                }
            }
            else // reverse
            {
                if (currentPointIndex > 0)
                {
                    PreviousDistance();
                }
                else
                {
                    // Reached the beginning, stop auto-advance
                    StopAutoAdvance();
                }
            }
        });
    }

    private async void NextDistance()
    {
        if (currentRoute == null || currentPointIndex >= currentRoute.Points.Count - 1)
            return;

        var targetIndex = FindNextPointByDistance(currentPointIndex, autoAdvanceDistanceMeters);
        if (targetIndex != currentPointIndex)
        {
            currentPointIndex = targetIndex;
            streetViewRefreshCounter++; // Force iframe refresh
            StateHasChanged();
            await UpdateMapPosition();
        }
    }

    private async void PreviousDistance()
    {
        if (currentRoute == null || currentPointIndex <= 0)
            return;

        var targetIndex = FindPreviousPointByDistance(currentPointIndex, autoAdvanceDistanceMeters);
        if (targetIndex != currentPointIndex)
        {
            currentPointIndex = targetIndex;
            streetViewRefreshCounter++; // Force iframe refresh
            StateHasChanged();
            await UpdateMapPosition();
        }
    }

    private int FindNextPointByDistance(int startIndex, int targetDistanceMeters)
    {
        if (currentRoute == null || startIndex >= currentRoute.Points.Count - 1)
            return startIndex;

        var startPoint = currentRoute.Points[startIndex];
        var accumulatedDistance = 0.0;

        for (int i = startIndex + 1; i < currentRoute.Points.Count; i++)
        {
            var currentPoint = currentRoute.Points[i];
            var previousPoint = currentRoute.Points[i - 1];
            
            // Calculate distance between consecutive points using Haversine formula
            var distance = CalculateDistance(previousPoint.Latitude, previousPoint.Longitude, 
                                           currentPoint.Latitude, currentPoint.Longitude);
            
            accumulatedDistance += distance;
            
            if (accumulatedDistance >= targetDistanceMeters)
            {
                return i;
            }
        }

        // If we didn't reach the target distance, return the last point
        return currentRoute.Points.Count - 1;
    }

    private int FindPreviousPointByDistance(int startIndex, int targetDistanceMeters)
    {
        if (currentRoute == null || startIndex <= 0)
            return startIndex;

        var accumulatedDistance = 0.0;

        for (int i = startIndex - 1; i >= 0; i--)
        {
            var currentPoint = currentRoute.Points[i];
            var nextPoint = currentRoute.Points[i + 1];
            
            // Calculate distance between current point and next point using Haversine formula
            var distance = CalculateDistance(currentPoint.Latitude, currentPoint.Longitude, 
                                           nextPoint.Latitude, nextPoint.Longitude);
            
            accumulatedDistance += distance;
            
            if (accumulatedDistance >= targetDistanceMeters)
            {
                return i;
            }
        }

        // If we didn't reach the target distance, return the first point
        return 0;
    }

    private double CalculateDistance(double lat1, double lon1, double lat2, double lon2)
    {
        // Haversine formula to calculate distance between two points on Earth
        const double R = 6371000; // Earth's radius in meters
        var dLat = (lat2 - lat1) * Math.PI / 180;
        var dLon = (lon2 - lon1) * Math.PI / 180;
        var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) +
                Math.Cos(lat1 * Math.PI / 180) * Math.Cos(lat2 * Math.PI / 180) *
                Math.Sin(dLon / 2) * Math.Sin(dLon / 2);
        var c = 2 * Math.Atan2(Math.Sqrt(a), Math.Sqrt(1 - a));
        return R * c;
    }

    private double CalculateOptimalHeading(RoutePoint currentPoint, int pointIndex)
    {
        if (currentRoute == null || currentRoute.Points.Count < 2)
            return 0; // Default heading if no route context

        RoutePoint? targetPoint = null;
        
        // Try to find the next point in the direction of travel
        if (pointIndex < currentRoute.Points.Count - 1)
        {
            targetPoint = currentRoute.Points[pointIndex + 1];
        }
        // If we're at the last point, use the previous point and reverse the bearing
        else if (pointIndex > 0)
        {
            var previousPoint = currentRoute.Points[pointIndex - 1];
            var reverseBearing = StreetViewService.CalculateBearing(previousPoint.Latitude, previousPoint.Longitude, 
                                                                 currentPoint.Latitude, currentPoint.Longitude);
            return reverseBearing;
        }
        
        // If we have a target point, calculate the bearing to it
        if (targetPoint != null)
        {
            return StreetViewService.CalculateBearing(currentPoint.Latitude, currentPoint.Longitude, 
                                                    targetPoint.Latitude, targetPoint.Longitude);
        }
        
        // Fallback to default heading
        return 0;
    }

    private double CalculateCurrentSpeed()
    {
        // Calculate speed based on current auto-advance settings
        // Speed = Distance / Time
        
        // Convert meters to miles: 1 meter = 0.000621371 miles
        var distanceMiles = autoAdvanceDistanceMeters * 0.000621371;
        
        // Convert seconds to hours: 1 second = 1/3600 hours
        var timeHours = autoAdvanceIntervalSeconds / 3600.0;
        
        // Calculate miles per hour
        var mph = distanceMiles / timeHours;
        
        return mph;
    }

    private async Task OnProgressBarClick(MouseEventArgs e)
    {
        if (currentRoute == null || !isNavigating) return;

        try
        {
            // Get the progress bar element and calculate click percentage
            var progressBarRect = await JSRuntime.InvokeAsync<object>("eval", @"
                (function() {
                    const progressBar = document.getElementById('clickable-progress');
                    if (!progressBar) return null;
                    const rect = progressBar.getBoundingClientRect();
                    return {
                        left: rect.left,
                        width: rect.width
                    };
                })()
            ");

            if (progressBarRect != null)
            {
                // Calculate click percentage manually
                var rect = System.Text.Json.JsonSerializer.Deserialize<dynamic>(progressBarRect.ToString()!);
                var left = ((System.Text.Json.JsonElement)rect).GetProperty("left").GetDouble();
                var width = ((System.Text.Json.JsonElement)rect).GetProperty("width").GetDouble();
                
                var clickPercentage = Math.Max(0, Math.Min(1, (e.ClientX - left) / width));
                
                // Calculate the target point index based on the clicked percentage
                var targetIndex = (int)Math.Round(clickPercentage * (currentRoute.Points.Count - 1));
                
                // Ensure the index is within bounds
                targetIndex = Math.Max(0, Math.Min(targetIndex, currentRoute.Points.Count - 1));
                
                // Jump to the selected point
                if (targetIndex != currentPointIndex)
                {
                    currentPointIndex = targetIndex;
                    streetViewRefreshCounter++; // Force iframe refresh
                    StateHasChanged();
                    await UpdateMapPosition();
                }
            }
        }
        catch (Exception ex)
        {
            // Handle any JavaScript errors gracefully
            Console.WriteLine($"Error handling progress bar click: {ex.Message}");
        }
    }

    private void RefreshStreetView()
    {
        // Force a re-render of the Street View by incrementing refresh counter and triggering a state change
        streetViewRefreshCounter++;
        StateHasChanged();
    }

    [JSInvokable]
    public static async Task OnMapRouteClick(int pointIndex)
    {
        if (_instance?.currentRoute == null || !_instance.isNavigating) 
            return;

        await _instance.InvokeAsync(async () =>
        {
            // Ensure the point index is within bounds
            pointIndex = Math.Max(0, Math.Min(pointIndex, _instance.currentRoute.Points.Count - 1));
            
            // Jump to the selected point
            if (pointIndex != _instance.currentPointIndex)
            {
                _instance.currentPointIndex = pointIndex;
                _instance.streetViewRefreshCounter++; // Force iframe refresh
                _instance.StateHasChanged();
                await _instance.UpdateMapPosition();
            }
        });
    }

    public void Dispose()
    {
        if (_instance == this)
            _instance = null;
        RouteService.CurrentRouteChanged -= OnCurrentRouteChanged;
        autoAdvanceTimer?.Dispose();
    }
}
